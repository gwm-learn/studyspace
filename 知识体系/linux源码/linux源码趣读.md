# 2025.3.3
1. 第一部分第一回 最开始的两行代码
```
CPU(pc寄存器) --> BIOS(位于ROM) --> 硬盘第一分区(操作系统最开始的代码<boot>) --> RAM(0x07c0 --> 0x7c00)
```

2. 第一部分第二回 从0x7c00到0x90000
```
0x7c00 --> 0x90000 --> 0x90000 + go
```

3. 第一部分第三回 做好访问内存的基础准备工作   
cpu访问内存的三种途径：访问代码的cs:ip，访问数据的ds:xxx，访问栈的ss:sp

4. 第一部分第四回 把全部的操作系统代码从硬盘搬到内存   
setup -- 4个扇区   system -- 240个扇区

# 2025.3.4
1. 中断   
中断分为中断和异常   
中断是通过外部设备给CPU的INTR引脚发送信号   
异常是CPU自己执行指令的时候发现特殊情况触发的   
还有INT指令，INT指令后面跟一个数字，就相当于直接用指令的形式，告诉CPU一个中断号   
linux一般会把中断分为上下两部分执行，上半部分处理简单的逻辑，将下半部分直接丢给一个软中断异步处理   

2. 第一部分第五回 将重要的操作系统代码放在零地址处   
0x90000地址开始存放系统信息(覆盖了一部分bootsect) --> 系统代码从0x10000~0x90000复制到0x0~0x80000位置   

# 2025.3.5
1. 第一部分第六回 解决段寄存器的历史包袱问题   
模式转换：16位的实模式转换为32位的保护模式   
实模式计算物理地址：段基址(ds寄存器值并且再左移四位)+偏移地址   
保护模式计算物理地址：段选择子中查找段描述符的索引，以此从全局描述符表中找到一个段描述符，段描述符中存着段基址。段基址+偏移地址   

2. 第一部分第七回 六行代码进入保护模式   
打开A20地址线(变32位可用) --> 切换保护模式 --> 跳转内存零地址   

3. 第一部分第八回 重新设置中断描述符表与全局描述符表   

4. 第一部分第九回 开启分页机制   

