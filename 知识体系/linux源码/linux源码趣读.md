# 2025.3.3
1. 第一部分第一回 最开始的两行代码
```
CPU(pc寄存器) --> BIOS(位于ROM) --> 硬盘第一分区(操作系统最开始的代码<boot>) --> RAM(0x07c0 --> 0x7c00)
```

2. 第一部分第二回 从0x7c00到0x90000
```
0x7c00 --> 0x90000 --> 0x90000 + go
```

3. 第一部分第三回 做好访问内存的基础准备工作   
cpu访问内存的三种途径：访问代码的cs:ip，访问数据的ds:xxx，访问栈的ss:sp

4. 第一部分第四回 把全部的操作系统代码从硬盘搬到内存   
setup -- 4个扇区   system -- 240个扇区

# 2025.3.4
1. 中断   
中断分为中断和异常   
中断是通过外部设备给CPU的INTR引脚发送信号   
异常是CPU自己执行指令的时候发现特殊情况触发的   
还有INT指令，INT指令后面跟一个数字，就相当于直接用指令的形式，告诉CPU一个中断号   
linux一般会把中断分为上下两部分执行，上半部分处理简单的逻辑，将下半部分直接丢给一个软中断异步处理   

2. 第一部分第五回 将重要的操作系统代码放在零地址处   
0x90000地址开始存放系统信息(覆盖了一部分bootsect) --> 系统代码从0x10000~0x90000复制到0x0~0x80000位置   

# 2025.3.5
1. 第一部分第六回 解决段寄存器的历史包袱问题   
模式转换：16位的实模式转换为32位的保护模式   
实模式计算物理地址：段基址(ds寄存器值并且再左移四位)+偏移地址   
保护模式计算物理地址：段选择子中查找段描述符的索引，以此从全局描述符表中找到一个段描述符，段描述符中存着段基址。段基址+偏移地址   

2. 第一部分第七回 六行代码进入保护模式   
打开A20地址线(变32位可用) --> 切换保护模式 --> 跳转内存零地址   

3. 第一部分第八回 重新设置中断描述符表与全局描述符表   

4. 第一部分第九回 开启分页机制   

# 2025.4.23
1. 第一部分第九回 开启分页机制   
CPU在看到内存地址后，会将地址拆分为高10位，中间10位，后12位。高10位负责在页目录表中找到一个页目录项，页目录项的值加上中间10位拼接后的地址去页表中找一个页表项，在加上后12位偏移地址就是最终物理地址   

2. 第一部分第十回 进入main函数前的最后一跃   
main 压栈 跳转执行main函数   

3. 第二部分第十一回 整个操作系统就二十几行代码   
参数取值和计算 初始化 用户态模式最终初始化   

4. 第二部分第十二回 管理内存前先划分出三个边界值   

5. 第二部分第十三回 主内存初始化mem_init   

# 2025.5.7
1. 第二部分第十四回 中断初始化 trap_init   

2. 第二部分第十五回 块设备请求项初始化blk_dev_init   

3. 第二部分第十六回 控制台初始化 tty_init   

4. 第二部分第十七回 时间初始化 time_init   

# 2025.5.9
1. 第二部分第十八回 进程调度初始化 sched_init   

2. 第二部分第十九回 缓冲区初始化 buffer_init   

3. 第二部分第二十回 硬盘初始化 hd_init   




