/*
 * Note: this file originally auto-generated by mib2c using
 *        $
*/

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <string.h>
#include "util.h"
#include "vendor.h"
#include "ipc_client.h"


/** Initializes the vendor module */
void init_vendor(void)
{
    const oid readTest_oid[] = { 1,3,6,1,4,1,36000,1 };
    const oid writeTest_oid[] = { 1,3,6,1,4,1,36000,2 };
    const oid SwitchMac_oid[] = { 1,3,6,1,4,1,36000,3 };

    DEBUGMSGTL(("vendor", "Initializing\n"));

    netsnmp_register_scalar(netsnmp_create_handler_registration("readTest", handle_readTest, readTest_oid, OID_LENGTH(readTest_oid), HANDLER_CAN_RONLY));
    netsnmp_register_scalar(netsnmp_create_handler_registration("writeTest", handle_writeTest, writeTest_oid, OID_LENGTH(writeTest_oid), HANDLER_CAN_RWRITE));
    netsnmp_register_scalar(netsnmp_create_handler_registration("SwitchMac", handle_SwitchMac,SwitchMac_oid, OID_LENGTH(SwitchMac_oid),HANDLER_CAN_RWRITE));

    if ((cj_plat_shm_init() >= 0) && (cj_client_init() >= 0))
        snmp_ipc_startup();
}

int handle_readTest(netsnmp_mib_handler *handler, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info *reqinfo, netsnmp_request_info *requests)
{
    int value = 36000;
    switch(reqinfo->mode) {
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER, &value, sizeof(value));
            break;
        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_readTest\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int handle_writeTest(netsnmp_mib_handler *handler, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info *reqinfo, netsnmp_request_info *requests)
{
    int ret;
    static char buf[1024] = "writeTest";

    switch(reqinfo->mode) {
        case MODE_SET_UNDO:
        case MODE_SET_FREE:
        case MODE_SET_COMMIT:
        case MODE_SET_RESERVE2:
            break;
        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR, buf, strlen(buf));
            break;
        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if (ret != SNMP_ERR_NOERROR)
                netsnmp_set_request_error(reqinfo, requests, ret);
            break;
        case MODE_SET_ACTION:
            if(requests->requestvb->val_len > 0 && requests->requestvb->val_len < 1023) {
                memcpy(buf, requests->requestvb->val.string, requests->requestvb->val_len);
                buf[requests->requestvb->val_len] = '\0';
            }else{
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
            break;
        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_writeTest\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int handle_SwitchMac(netsnmp_mib_handler *handler, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info *reqinfo, netsnmp_request_info *requests)
{
    int ret;
    char mac[16] = {0};
    static char buf[MSG_LEN] = {0};
    cj_ctl_msg_t msg;
    cj_ctl_msg_t *recv_msg;

    memset((char *)&msg, 0, sizeof(msg));

    switch(reqinfo->mode) {
        case MODE_SET_UNDO:
        case MODE_SET_FREE:
        case MODE_SET_COMMIT:
        case MODE_SET_RESERVE2:
            break;
        case MODE_GET:
            msg.msg_type  = CJ_MSG_TYPE_SNMP;
            msg.protorl   = CJ_CLIENT_SNMP;
            msg.sub_type.snmp_type = CJ_MSG_SNMP_SUB_TYPE_GET_MAC;
            snmp_get_msg(&msg, sizeof(msg), buf, sizeof(buf), sockfd);
            recv_msg = (cj_ctl_msg_t *)buf;
            arrayToStr((unsigned char *)(recv_msg->msg.mac), sizeof(recv_msg->msg.mac), mac);
            printf("[SNMPD] CJ_MSG_SNMP_SUB_TYPE_GET_MAC\nmac hex:%x\nmac str:%s\n", recv_msg->msg.mac, mac);
            snmp_set_var_typed_value( requests->requestvb, ASN_OCTET_STR, mac, strlen(mac));
            break;
        case MODE_SET_RESERVE1:
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if (ret != SNMP_ERR_NOERROR)
                netsnmp_set_request_error(reqinfo, requests, ret);
            break;
        case MODE_SET_ACTION:
            if(requests->requestvb->val_len > 0 && requests->requestvb->val_len <= 16){
                msg.msg_type  = CJ_MSG_TYPE_SNMP;
                msg.protorl   = CJ_CLIENT_SNMP;
                msg.sub_type.snmp_type = CJ_MSG_SNMP_SUB_TYPE_SET_MAC;
                StringToHex(requests->requestvb->val.string, msg.msg.mac, &(requests->requestvb->val_len));
                printf("[SNMPD] CJ_MSG_SNMP_SUB_TYPE_SET_MAC\nmac hex:%x\nmac str:%s\n", msg.msg.mac, requests->requestvb->val.string);
                snmp_set_msg(&msg, sizeof(msg), sockfd);
            }else{
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            }
            break;
        default:
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_writeTest\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}